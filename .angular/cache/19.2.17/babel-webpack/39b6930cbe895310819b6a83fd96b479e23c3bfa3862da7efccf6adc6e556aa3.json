{"ast":null,"code":"/**\n * @license Angular v19.2.15\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { ɵRuntimeError as _RuntimeError, ApplicationRef, Injectable, makeEnvironmentProviders, InjectionToken, Injector, provideAppInitializer, inject, NgZone, ɵformatRuntimeError as _formatRuntimeError, NgModule } from '@angular/core';\nimport { Observable, Subject, NEVER } from 'rxjs';\nimport { switchMap, take, filter, map } from 'rxjs/operators';\nconst ERR_SW_NOT_SUPPORTED = 'Service workers are disabled or not supported by this browser';\n/**\n * @publicApi\n */\nclass NgswCommChannel {\n  serviceWorker;\n  worker;\n  registration;\n  events;\n  constructor(serviceWorker, injector) {\n    this.serviceWorker = serviceWorker;\n    if (!serviceWorker) {\n      this.worker = this.events = this.registration = new Observable(subscriber => subscriber.error(new _RuntimeError(5601 /* RuntimeErrorCode.SERVICE_WORKER_DISABLED_OR_NOT_SUPPORTED_BY_THIS_BROWSER */, (typeof ngDevMode === 'undefined' || ngDevMode) && ERR_SW_NOT_SUPPORTED)));\n    } else {\n      let currentWorker = null;\n      const workerSubject = new Subject();\n      this.worker = new Observable(subscriber => {\n        if (currentWorker !== null) {\n          subscriber.next(currentWorker);\n        }\n        return workerSubject.subscribe(v => subscriber.next(v));\n      });\n      const updateController = () => {\n        const {\n          controller\n        } = serviceWorker;\n        if (controller === null) {\n          return;\n        }\n        currentWorker = controller;\n        workerSubject.next(currentWorker);\n      };\n      serviceWorker.addEventListener('controllerchange', updateController);\n      updateController();\n      this.registration = this.worker.pipe(switchMap(() => serviceWorker.getRegistration()));\n      const _events = new Subject();\n      this.events = _events.asObservable();\n      const messageListener = event => {\n        const {\n          data\n        } = event;\n        if (data?.type) {\n          _events.next(data);\n        }\n      };\n      serviceWorker.addEventListener('message', messageListener);\n      // The injector is optional to avoid breaking changes.\n      const appRef = injector?.get(ApplicationRef, null, {\n        optional: true\n      });\n      appRef?.onDestroy(() => {\n        serviceWorker.removeEventListener('controllerchange', updateController);\n        serviceWorker.removeEventListener('message', messageListener);\n      });\n    }\n  }\n  postMessage(action, payload) {\n    return new Promise(resolve => {\n      this.worker.pipe(take(1)).subscribe(sw => {\n        sw.postMessage({\n          action,\n          ...payload\n        });\n        resolve();\n      });\n    });\n  }\n  postMessageWithOperation(type, payload, operationNonce) {\n    const waitForOperationCompleted = this.waitForOperationCompleted(operationNonce);\n    const postMessage = this.postMessage(type, payload);\n    return Promise.all([postMessage, waitForOperationCompleted]).then(([, result]) => result);\n  }\n  generateNonce() {\n    return Math.round(Math.random() * 10000000);\n  }\n  eventsOfType(type) {\n    let filterFn;\n    if (typeof type === 'string') {\n      filterFn = event => event.type === type;\n    } else {\n      filterFn = event => type.includes(event.type);\n    }\n    return this.events.pipe(filter(filterFn));\n  }\n  nextEventOfType(type) {\n    return this.eventsOfType(type).pipe(take(1));\n  }\n  waitForOperationCompleted(nonce) {\n    return new Promise((resolve, reject) => {\n      this.eventsOfType('OPERATION_COMPLETED').pipe(filter(event => event.nonce === nonce), take(1), map(event => {\n        if (event.result !== undefined) {\n          return event.result;\n        }\n        throw new Error(event.error);\n      })).subscribe({\n        next: resolve,\n        error: reject\n      });\n    });\n  }\n  get isEnabled() {\n    return !!this.serviceWorker;\n  }\n}\n\n/**\n * Subscribe and listen to\n * [Web Push\n * Notifications](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices) through\n * Angular Service Worker.\n *\n * @usageNotes\n *\n * You can inject a `SwPush` instance into any component or service\n * as a dependency.\n *\n * <code-example path=\"service-worker/push/module.ts\" region=\"inject-sw-push\"\n * header=\"app.component.ts\"></code-example>\n *\n * To subscribe, call `SwPush.requestSubscription()`, which asks the user for permission.\n * The call returns a `Promise` with a new\n * [`PushSubscription`](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\n * instance.\n *\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-push\"\n * header=\"app.component.ts\"></code-example>\n *\n * A request is rejected if the user denies permission, or if the browser\n * blocks or does not support the Push API or ServiceWorkers.\n * Check `SwPush.isEnabled` to confirm status.\n *\n * Invoke Push Notifications by pushing a message with the following payload.\n *\n * ```ts\n * {\n *   \"notification\": {\n *     \"actions\": NotificationAction[],\n *     \"badge\": USVString,\n *     \"body\": DOMString,\n *     \"data\": any,\n *     \"dir\": \"auto\"|\"ltr\"|\"rtl\",\n *     \"icon\": USVString,\n *     \"image\": USVString,\n *     \"lang\": DOMString,\n *     \"renotify\": boolean,\n *     \"requireInteraction\": boolean,\n *     \"silent\": boolean,\n *     \"tag\": DOMString,\n *     \"timestamp\": DOMTimeStamp,\n *     \"title\": DOMString,\n *     \"vibrate\": number[]\n *   }\n * }\n * ```\n *\n * Only `title` is required. See `Notification`\n * [instance\n * properties](https://developer.mozilla.org/en-US/docs/Web/API/Notification#Instance_properties).\n *\n * While the subscription is active, Service Worker listens for\n * [PushEvent](https://developer.mozilla.org/en-US/docs/Web/API/PushEvent)\n * occurrences and creates\n * [Notification](https://developer.mozilla.org/en-US/docs/Web/API/Notification)\n * instances in response.\n *\n * Unsubscribe using `SwPush.unsubscribe()`.\n *\n * An application can subscribe to `SwPush.notificationClicks` observable to be notified when a user\n * clicks on a notification. For example:\n *\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-notification-clicks\"\n * header=\"app.component.ts\"></code-example>\n *\n * You can read more on handling notification clicks in the [Service worker notifications\n * guide](ecosystem/service-workers/push-notifications).\n *\n * @see [Push Notifications](https://developers.google.com/web/fundamentals/codelabs/push-notifications/)\n * @see [Angular Push Notifications](https://blog.angular-university.io/angular-push-notifications/)\n * @see [MDN: Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)\n * @see [MDN: Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API)\n * @see [MDN: Web Push API Notifications best practices](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices)\n *\n * @publicApi\n */\nclass SwPush {\n  sw;\n  /**\n   * Emits the payloads of the received push notification messages.\n   */\n  messages;\n  /**\n   * Emits the payloads of the received push notification messages as well as the action the user\n   * interacted with. If no action was used the `action` property contains an empty string `''`.\n   *\n   * Note that the `notification` property does **not** contain a\n   * [Notification][Mozilla Notification] object but rather a\n   * [NotificationOptions](https://notifications.spec.whatwg.org/#dictdef-notificationoptions)\n   * object that also includes the `title` of the [Notification][Mozilla Notification] object.\n   *\n   * [Mozilla Notification]: https://developer.mozilla.org/en-US/docs/Web/API/Notification\n   */\n  notificationClicks;\n  /**\n   * Emits the currently active\n   * [PushSubscription](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\n   * associated to the Service Worker registration or `null` if there is no subscription.\n   */\n  subscription;\n  /**\n   * True if the Service Worker is enabled (supported by the browser and enabled via\n   * `ServiceWorkerModule`).\n   */\n  get isEnabled() {\n    return this.sw.isEnabled;\n  }\n  pushManager = null;\n  subscriptionChanges = new Subject();\n  constructor(sw) {\n    this.sw = sw;\n    if (!sw.isEnabled) {\n      this.messages = NEVER;\n      this.notificationClicks = NEVER;\n      this.subscription = NEVER;\n      return;\n    }\n    this.messages = this.sw.eventsOfType('PUSH').pipe(map(message => message.data));\n    this.notificationClicks = this.sw.eventsOfType('NOTIFICATION_CLICK').pipe(map(message => message.data));\n    this.pushManager = this.sw.registration.pipe(map(registration => registration.pushManager));\n    const workerDrivenSubscriptions = this.pushManager.pipe(switchMap(pm => pm.getSubscription()));\n    this.subscription = new Observable(subscriber => {\n      const workerDrivenSubscription = workerDrivenSubscriptions.subscribe(subscriber);\n      const subscriptionChanges = this.subscriptionChanges.subscribe(subscriber);\n      return () => {\n        workerDrivenSubscription.unsubscribe();\n        subscriptionChanges.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Subscribes to Web Push Notifications,\n   * after requesting and receiving user permission.\n   *\n   * @param options An object containing the `serverPublicKey` string.\n   * @returns A Promise that resolves to the new subscription object.\n   */\n  requestSubscription(options) {\n    if (!this.sw.isEnabled || this.pushManager === null) {\n      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n    }\n    const pushOptions = {\n      userVisibleOnly: true\n    };\n    let key = this.decodeBase64(options.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+'));\n    let applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));\n    for (let i = 0; i < key.length; i++) {\n      applicationServerKey[i] = key.charCodeAt(i);\n    }\n    pushOptions.applicationServerKey = applicationServerKey;\n    return new Promise((resolve, reject) => {\n      this.pushManager.pipe(switchMap(pm => pm.subscribe(pushOptions)), take(1)).subscribe({\n        next: sub => {\n          this.subscriptionChanges.next(sub);\n          resolve(sub);\n        },\n        error: reject\n      });\n    });\n  }\n  /**\n   * Unsubscribes from Service Worker push notifications.\n   *\n   * @returns A Promise that is resolved when the operation succeeds, or is rejected if there is no\n   *          active subscription or the unsubscribe operation fails.\n   */\n  unsubscribe() {\n    if (!this.sw.isEnabled) {\n      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n    }\n    const doUnsubscribe = sub => {\n      if (sub === null) {\n        throw new _RuntimeError(5602 /* RuntimeErrorCode.NOT_SUBSCRIBED_TO_PUSH_NOTIFICATIONS */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Not subscribed to push notifications.');\n      }\n      return sub.unsubscribe().then(success => {\n        if (!success) {\n          throw new _RuntimeError(5603 /* RuntimeErrorCode.PUSH_SUBSCRIPTION_UNSUBSCRIBE_FAILED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Unsubscribe failed!');\n        }\n        this.subscriptionChanges.next(null);\n      });\n    };\n    return new Promise((resolve, reject) => {\n      this.subscription.pipe(take(1), switchMap(doUnsubscribe)).subscribe({\n        next: resolve,\n        error: reject\n      });\n    });\n  }\n  decodeBase64(input) {\n    return atob(input);\n  }\n  static ɵfac = function SwPush_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || SwPush)(i0.ɵɵinject(NgswCommChannel));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SwPush,\n    factory: SwPush.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwPush, [{\n    type: Injectable\n  }], () => [{\n    type: NgswCommChannel\n  }], null);\n})();\n\n/**\n * Subscribe to update notifications from the Service Worker, trigger update\n * checks, and forcibly activate updates.\n *\n * @see {@link /ecosystem/service-workers/communications Service Worker Communication Guide}\n *\n * @publicApi\n */\nclass SwUpdate {\n  sw;\n  /**\n   * Emits a `VersionDetectedEvent` event whenever a new version is detected on the server.\n   *\n   * Emits a `VersionInstallationFailedEvent` event whenever checking for or downloading a new\n   * version fails.\n   *\n   * Emits a `VersionReadyEvent` event whenever a new version has been downloaded and is ready for\n   * activation.\n   */\n  versionUpdates;\n  /**\n   * Emits an `UnrecoverableStateEvent` event whenever the version of the app used by the service\n   * worker to serve this client is in a broken state that cannot be recovered from without a full\n   * page reload.\n   */\n  unrecoverable;\n  /**\n   * True if the Service Worker is enabled (supported by the browser and enabled via\n   * `ServiceWorkerModule`).\n   */\n  get isEnabled() {\n    return this.sw.isEnabled;\n  }\n  constructor(sw) {\n    this.sw = sw;\n    if (!sw.isEnabled) {\n      this.versionUpdates = NEVER;\n      this.unrecoverable = NEVER;\n      return;\n    }\n    this.versionUpdates = this.sw.eventsOfType(['VERSION_DETECTED', 'VERSION_INSTALLATION_FAILED', 'VERSION_READY', 'NO_NEW_VERSION_DETECTED']);\n    this.unrecoverable = this.sw.eventsOfType('UNRECOVERABLE_STATE');\n  }\n  /**\n   * Checks for an update and waits until the new version is downloaded from the server and ready\n   * for activation.\n   *\n   * @returns a promise that\n   * - resolves to `true` if a new version was found and is ready to be activated.\n   * - resolves to `false` if no new version was found\n   * - rejects if any error occurs\n   */\n  checkForUpdate() {\n    if (!this.sw.isEnabled) {\n      return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n    }\n    const nonce = this.sw.generateNonce();\n    return this.sw.postMessageWithOperation('CHECK_FOR_UPDATES', {\n      nonce\n    }, nonce);\n  }\n  /**\n   * Updates the current client (i.e. browser tab) to the latest version that is ready for\n   * activation.\n   *\n   * In most cases, you should not use this method and instead should update a client by reloading\n   * the page.\n   *\n   * <div class=\"docs-alert docs-alert-important\">\n   *\n   * Updating a client without reloading can easily result in a broken application due to a version\n   * mismatch between the application shell and other page resources,\n   * such as lazy-loaded chunks, whose filenames may change between\n   * versions.\n   *\n   * Only use this method, if you are certain it is safe for your specific use case.\n   *\n   * </div>\n   *\n   * @returns a promise that\n   *  - resolves to `true` if an update was activated successfully\n   *  - resolves to `false` if no update was available (for example, the client was already on the\n   *    latest version).\n   *  - rejects if any error occurs\n   */\n  activateUpdate() {\n    if (!this.sw.isEnabled) {\n      return Promise.reject(new _RuntimeError(5601 /* RuntimeErrorCode.SERVICE_WORKER_DISABLED_OR_NOT_SUPPORTED_BY_THIS_BROWSER */, (typeof ngDevMode === 'undefined' || ngDevMode) && ERR_SW_NOT_SUPPORTED));\n    }\n    const nonce = this.sw.generateNonce();\n    return this.sw.postMessageWithOperation('ACTIVATE_UPDATE', {\n      nonce\n    }, nonce);\n  }\n  static ɵfac = function SwUpdate_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || SwUpdate)(i0.ɵɵinject(NgswCommChannel));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SwUpdate,\n    factory: SwUpdate.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwUpdate, [{\n    type: Injectable\n  }], () => [{\n    type: NgswCommChannel\n  }], null);\n})();\n\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nconst SCRIPT = new InjectionToken(ngDevMode ? 'NGSW_REGISTER_SCRIPT' : '');\nfunction ngswAppInitializer() {\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    return;\n  }\n  const options = inject(SwRegistrationOptions);\n  if (!('serviceWorker' in navigator && options.enabled !== false)) {\n    return;\n  }\n  const script = inject(SCRIPT);\n  const ngZone = inject(NgZone);\n  const appRef = inject(ApplicationRef);\n  // Set up the `controllerchange` event listener outside of\n  // the Angular zone to avoid unnecessary change detections,\n  // as this event has no impact on view updates.\n  ngZone.runOutsideAngular(() => {\n    // Wait for service worker controller changes, and fire an INITIALIZE action when a new SW\n    // becomes active. This allows the SW to initialize itself even if there is no application\n    // traffic.\n    const sw = navigator.serviceWorker;\n    const onControllerChange = () => sw.controller?.postMessage({\n      action: 'INITIALIZE'\n    });\n    sw.addEventListener('controllerchange', onControllerChange);\n    appRef.onDestroy(() => {\n      sw.removeEventListener('controllerchange', onControllerChange);\n    });\n  });\n  // Run outside the Angular zone to avoid preventing the app from stabilizing (especially\n  // given that some registration strategies wait for the app to stabilize).\n  ngZone.runOutsideAngular(() => {\n    let readyToRegister;\n    const {\n      registrationStrategy\n    } = options;\n    if (typeof registrationStrategy === 'function') {\n      readyToRegister = new Promise(resolve => registrationStrategy().subscribe(() => resolve()));\n    } else {\n      const [strategy, ...args] = (registrationStrategy || 'registerWhenStable:30000').split(':');\n      switch (strategy) {\n        case 'registerImmediately':\n          readyToRegister = Promise.resolve();\n          break;\n        case 'registerWithDelay':\n          readyToRegister = delayWithTimeout(+args[0] || 0);\n          break;\n        case 'registerWhenStable':\n          readyToRegister = Promise.race([appRef.whenStable(), delayWithTimeout(+args[0])]);\n          break;\n        default:\n          // Unknown strategy.\n          throw new _RuntimeError(5600 /* RuntimeErrorCode.UNKNOWN_REGISTRATION_STRATEGY */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Unknown ServiceWorker registration strategy: ${options.registrationStrategy}`);\n      }\n    }\n    // Don't return anything to avoid blocking the application until the SW is registered.\n    // Catch and log the error if SW registration fails to avoid uncaught rejection warning.\n    readyToRegister.then(() => {\n      // If the registration strategy has resolved after the application has\n      // been explicitly destroyed by the user (e.g., by navigating away to\n      // another application), we simply should not register the worker.\n      if (appRef.destroyed) {\n        return;\n      }\n      navigator.serviceWorker.register(script, {\n        scope: options.scope\n      }).catch(err => console.error(_formatRuntimeError(5604 /* RuntimeErrorCode.SERVICE_WORKER_REGISTRATION_FAILED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Service worker registration failed with: ' + err)));\n    });\n  });\n}\nfunction delayWithTimeout(timeout) {\n  return new Promise(resolve => setTimeout(resolve, timeout));\n}\nfunction ngswCommChannelFactory(opts, injector) {\n  const isBrowser = !(typeof ngServerMode !== 'undefined' && ngServerMode);\n  return new NgswCommChannel(isBrowser && opts.enabled !== false ? navigator.serviceWorker : undefined, injector);\n}\n/**\n * Token that can be used to provide options for `ServiceWorkerModule` outside of\n * `ServiceWorkerModule.register()`.\n *\n * You can use this token to define a provider that generates the registration options at runtime,\n * for example via a function call:\n *\n * {@example service-worker/registration-options/module.ts region=\"registration-options\"\n *     header=\"app.module.ts\"}\n *\n * @publicApi\n */\nclass SwRegistrationOptions {\n  /**\n   * Whether the ServiceWorker will be registered and the related services (such as `SwPush` and\n   * `SwUpdate`) will attempt to communicate and interact with it.\n   *\n   * Default: true\n   */\n  enabled;\n  /**\n   * A URL that defines the ServiceWorker's registration scope; that is, what range of URLs it can\n   * control. It will be used when calling\n   * [ServiceWorkerContainer#register()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).\n   */\n  scope;\n  /**\n   * Defines the ServiceWorker registration strategy, which determines when it will be registered\n   * with the browser.\n   *\n   * The default behavior of registering once the application stabilizes (i.e. as soon as there are\n   * no pending micro- and macro-tasks) is designed to register the ServiceWorker as soon as\n   * possible but without affecting the application's first time load.\n   *\n   * Still, there might be cases where you want more control over when the ServiceWorker is\n   * registered (for example, there might be a long-running timeout or polling interval, preventing\n   * the app from stabilizing). The available option are:\n   *\n   * - `registerWhenStable:<timeout>`: Register as soon as the application stabilizes (no pending\n   *     micro-/macro-tasks) but no later than `<timeout>` milliseconds. If the app hasn't\n   *     stabilized after `<timeout>` milliseconds (for example, due to a recurrent asynchronous\n   *     task), the ServiceWorker will be registered anyway.\n   *     If `<timeout>` is omitted, the ServiceWorker will only be registered once the app\n   *     stabilizes.\n   * - `registerImmediately`: Register immediately.\n   * - `registerWithDelay:<timeout>`: Register with a delay of `<timeout>` milliseconds. For\n   *     example, use `registerWithDelay:5000` to register the ServiceWorker after 5 seconds. If\n   *     `<timeout>` is omitted, is defaults to `0`, which will register the ServiceWorker as soon\n   *     as possible but still asynchronously, once all pending micro-tasks are completed.\n   * - An Observable factory function: A function that returns an `Observable`.\n   *     The function will be used at runtime to obtain and subscribe to the `Observable` and the\n   *     ServiceWorker will be registered as soon as the first value is emitted.\n   *\n   * Default: 'registerWhenStable:30000'\n   */\n  registrationStrategy;\n}\n/**\n * @publicApi\n *\n * Sets up providers to register the given Angular Service Worker script.\n *\n * If `enabled` is set to `false` in the given options, the module will behave as if service\n * workers are not supported by the browser, and the service worker will not be registered.\n *\n * Example usage:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideServiceWorker('ngsw-worker.js')\n *   ],\n * });\n * ```\n */\nfunction provideServiceWorker(script, options = {}) {\n  return makeEnvironmentProviders([SwPush, SwUpdate, {\n    provide: SCRIPT,\n    useValue: script\n  }, {\n    provide: SwRegistrationOptions,\n    useValue: options\n  }, {\n    provide: NgswCommChannel,\n    useFactory: ngswCommChannelFactory,\n    deps: [SwRegistrationOptions, Injector]\n  }, provideAppInitializer(ngswAppInitializer)]);\n}\n\n/**\n * @publicApi\n */\nclass ServiceWorkerModule {\n  /**\n   * Register the given Angular Service Worker script.\n   *\n   * If `enabled` is set to `false` in the given options, the module will behave as if service\n   * workers are not supported by the browser, and the service worker will not be registered.\n   */\n  static register(script, options = {}) {\n    return {\n      ngModule: ServiceWorkerModule,\n      providers: [provideServiceWorker(script, options)]\n    };\n  }\n  static ɵfac = function ServiceWorkerModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ServiceWorkerModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ServiceWorkerModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [SwPush, SwUpdate]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ServiceWorkerModule, [{\n    type: NgModule,\n    args: [{\n      providers: [SwPush, SwUpdate]\n    }]\n  }], null, null);\n})();\nexport { ServiceWorkerModule, SwPush, SwRegistrationOptions, SwUpdate, provideServiceWorker };","map":{"version":3,"names":["i0","ɵRuntimeError","_RuntimeError","ApplicationRef","Injectable","makeEnvironmentProviders","InjectionToken","Injector","provideAppInitializer","inject","NgZone","ɵformatRuntimeError","_formatRuntimeError","NgModule","Observable","Subject","NEVER","switchMap","take","filter","map","ERR_SW_NOT_SUPPORTED","NgswCommChannel","serviceWorker","worker","registration","events","constructor","injector","subscriber","error","ngDevMode","currentWorker","workerSubject","next","subscribe","v","updateController","controller","addEventListener","pipe","getRegistration","_events","asObservable","messageListener","event","data","type","appRef","get","optional","onDestroy","removeEventListener","postMessage","action","payload","Promise","resolve","sw","postMessageWithOperation","operationNonce","waitForOperationCompleted","all","then","result","generateNonce","Math","round","random","eventsOfType","filterFn","includes","nextEventOfType","nonce","reject","undefined","Error","isEnabled","SwPush","messages","notificationClicks","subscription","pushManager","subscriptionChanges","message","workerDrivenSubscriptions","pm","getSubscription","workerDrivenSubscription","unsubscribe","requestSubscription","options","pushOptions","userVisibleOnly","key","decodeBase64","serverPublicKey","replace","applicationServerKey","Uint8Array","ArrayBuffer","length","i","charCodeAt","sub","doUnsubscribe","success","input","atob","ɵfac","SwPush_Factory","__ngFactoryType__","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ɵsetClassMetadata","SwUpdate","versionUpdates","unrecoverable","checkForUpdate","activateUpdate","SwUpdate_Factory","SCRIPT","ngswAppInitializer","ngServerMode","SwRegistrationOptions","navigator","enabled","script","ngZone","runOutsideAngular","onControllerChange","readyToRegister","registrationStrategy","strategy","args","split","delayWithTimeout","race","whenStable","destroyed","register","scope","catch","err","console","timeout","setTimeout","ngswCommChannelFactory","opts","isBrowser","provideServiceWorker","provide","useValue","useFactory","deps","ServiceWorkerModule","ngModule","providers","ServiceWorkerModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector"],"sources":["D:/Documents/GitHub/Foosball-Manager#/node_modules/@angular/service-worker/fesm2022/service-worker.mjs"],"sourcesContent":["/**\n * @license Angular v19.2.15\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { ɵRuntimeError as _RuntimeError, ApplicationRef, Injectable, makeEnvironmentProviders, InjectionToken, Injector, provideAppInitializer, inject, NgZone, ɵformatRuntimeError as _formatRuntimeError, NgModule } from '@angular/core';\nimport { Observable, Subject, NEVER } from 'rxjs';\nimport { switchMap, take, filter, map } from 'rxjs/operators';\n\nconst ERR_SW_NOT_SUPPORTED = 'Service workers are disabled or not supported by this browser';\n/**\n * @publicApi\n */\nclass NgswCommChannel {\n    serviceWorker;\n    worker;\n    registration;\n    events;\n    constructor(serviceWorker, injector) {\n        this.serviceWorker = serviceWorker;\n        if (!serviceWorker) {\n            this.worker =\n                this.events =\n                    this.registration =\n                        new Observable((subscriber) => subscriber.error(new _RuntimeError(5601 /* RuntimeErrorCode.SERVICE_WORKER_DISABLED_OR_NOT_SUPPORTED_BY_THIS_BROWSER */, (typeof ngDevMode === 'undefined' || ngDevMode) && ERR_SW_NOT_SUPPORTED)));\n        }\n        else {\n            let currentWorker = null;\n            const workerSubject = new Subject();\n            this.worker = new Observable((subscriber) => {\n                if (currentWorker !== null) {\n                    subscriber.next(currentWorker);\n                }\n                return workerSubject.subscribe((v) => subscriber.next(v));\n            });\n            const updateController = () => {\n                const { controller } = serviceWorker;\n                if (controller === null) {\n                    return;\n                }\n                currentWorker = controller;\n                workerSubject.next(currentWorker);\n            };\n            serviceWorker.addEventListener('controllerchange', updateController);\n            updateController();\n            this.registration = (this.worker.pipe(switchMap(() => serviceWorker.getRegistration())));\n            const _events = new Subject();\n            this.events = _events.asObservable();\n            const messageListener = (event) => {\n                const { data } = event;\n                if (data?.type) {\n                    _events.next(data);\n                }\n            };\n            serviceWorker.addEventListener('message', messageListener);\n            // The injector is optional to avoid breaking changes.\n            const appRef = injector?.get(ApplicationRef, null, { optional: true });\n            appRef?.onDestroy(() => {\n                serviceWorker.removeEventListener('controllerchange', updateController);\n                serviceWorker.removeEventListener('message', messageListener);\n            });\n        }\n    }\n    postMessage(action, payload) {\n        return new Promise((resolve) => {\n            this.worker.pipe(take(1)).subscribe((sw) => {\n                sw.postMessage({\n                    action,\n                    ...payload,\n                });\n                resolve();\n            });\n        });\n    }\n    postMessageWithOperation(type, payload, operationNonce) {\n        const waitForOperationCompleted = this.waitForOperationCompleted(operationNonce);\n        const postMessage = this.postMessage(type, payload);\n        return Promise.all([postMessage, waitForOperationCompleted]).then(([, result]) => result);\n    }\n    generateNonce() {\n        return Math.round(Math.random() * 10000000);\n    }\n    eventsOfType(type) {\n        let filterFn;\n        if (typeof type === 'string') {\n            filterFn = (event) => event.type === type;\n        }\n        else {\n            filterFn = (event) => type.includes(event.type);\n        }\n        return this.events.pipe(filter(filterFn));\n    }\n    nextEventOfType(type) {\n        return this.eventsOfType(type).pipe(take(1));\n    }\n    waitForOperationCompleted(nonce) {\n        return new Promise((resolve, reject) => {\n            this.eventsOfType('OPERATION_COMPLETED')\n                .pipe(filter((event) => event.nonce === nonce), take(1), map((event) => {\n                if (event.result !== undefined) {\n                    return event.result;\n                }\n                throw new Error(event.error);\n            }))\n                .subscribe({\n                next: resolve,\n                error: reject,\n            });\n        });\n    }\n    get isEnabled() {\n        return !!this.serviceWorker;\n    }\n}\n\n/**\n * Subscribe and listen to\n * [Web Push\n * Notifications](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices) through\n * Angular Service Worker.\n *\n * @usageNotes\n *\n * You can inject a `SwPush` instance into any component or service\n * as a dependency.\n *\n * <code-example path=\"service-worker/push/module.ts\" region=\"inject-sw-push\"\n * header=\"app.component.ts\"></code-example>\n *\n * To subscribe, call `SwPush.requestSubscription()`, which asks the user for permission.\n * The call returns a `Promise` with a new\n * [`PushSubscription`](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\n * instance.\n *\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-push\"\n * header=\"app.component.ts\"></code-example>\n *\n * A request is rejected if the user denies permission, or if the browser\n * blocks or does not support the Push API or ServiceWorkers.\n * Check `SwPush.isEnabled` to confirm status.\n *\n * Invoke Push Notifications by pushing a message with the following payload.\n *\n * ```ts\n * {\n *   \"notification\": {\n *     \"actions\": NotificationAction[],\n *     \"badge\": USVString,\n *     \"body\": DOMString,\n *     \"data\": any,\n *     \"dir\": \"auto\"|\"ltr\"|\"rtl\",\n *     \"icon\": USVString,\n *     \"image\": USVString,\n *     \"lang\": DOMString,\n *     \"renotify\": boolean,\n *     \"requireInteraction\": boolean,\n *     \"silent\": boolean,\n *     \"tag\": DOMString,\n *     \"timestamp\": DOMTimeStamp,\n *     \"title\": DOMString,\n *     \"vibrate\": number[]\n *   }\n * }\n * ```\n *\n * Only `title` is required. See `Notification`\n * [instance\n * properties](https://developer.mozilla.org/en-US/docs/Web/API/Notification#Instance_properties).\n *\n * While the subscription is active, Service Worker listens for\n * [PushEvent](https://developer.mozilla.org/en-US/docs/Web/API/PushEvent)\n * occurrences and creates\n * [Notification](https://developer.mozilla.org/en-US/docs/Web/API/Notification)\n * instances in response.\n *\n * Unsubscribe using `SwPush.unsubscribe()`.\n *\n * An application can subscribe to `SwPush.notificationClicks` observable to be notified when a user\n * clicks on a notification. For example:\n *\n * <code-example path=\"service-worker/push/module.ts\" region=\"subscribe-to-notification-clicks\"\n * header=\"app.component.ts\"></code-example>\n *\n * You can read more on handling notification clicks in the [Service worker notifications\n * guide](ecosystem/service-workers/push-notifications).\n *\n * @see [Push Notifications](https://developers.google.com/web/fundamentals/codelabs/push-notifications/)\n * @see [Angular Push Notifications](https://blog.angular-university.io/angular-push-notifications/)\n * @see [MDN: Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)\n * @see [MDN: Notifications API](https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API)\n * @see [MDN: Web Push API Notifications best practices](https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Best_Practices)\n *\n * @publicApi\n */\nclass SwPush {\n    sw;\n    /**\n     * Emits the payloads of the received push notification messages.\n     */\n    messages;\n    /**\n     * Emits the payloads of the received push notification messages as well as the action the user\n     * interacted with. If no action was used the `action` property contains an empty string `''`.\n     *\n     * Note that the `notification` property does **not** contain a\n     * [Notification][Mozilla Notification] object but rather a\n     * [NotificationOptions](https://notifications.spec.whatwg.org/#dictdef-notificationoptions)\n     * object that also includes the `title` of the [Notification][Mozilla Notification] object.\n     *\n     * [Mozilla Notification]: https://developer.mozilla.org/en-US/docs/Web/API/Notification\n     */\n    notificationClicks;\n    /**\n     * Emits the currently active\n     * [PushSubscription](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription)\n     * associated to the Service Worker registration or `null` if there is no subscription.\n     */\n    subscription;\n    /**\n     * True if the Service Worker is enabled (supported by the browser and enabled via\n     * `ServiceWorkerModule`).\n     */\n    get isEnabled() {\n        return this.sw.isEnabled;\n    }\n    pushManager = null;\n    subscriptionChanges = new Subject();\n    constructor(sw) {\n        this.sw = sw;\n        if (!sw.isEnabled) {\n            this.messages = NEVER;\n            this.notificationClicks = NEVER;\n            this.subscription = NEVER;\n            return;\n        }\n        this.messages = this.sw.eventsOfType('PUSH').pipe(map((message) => message.data));\n        this.notificationClicks = this.sw\n            .eventsOfType('NOTIFICATION_CLICK')\n            .pipe(map((message) => message.data));\n        this.pushManager = this.sw.registration.pipe(map((registration) => registration.pushManager));\n        const workerDrivenSubscriptions = this.pushManager.pipe(switchMap((pm) => pm.getSubscription()));\n        this.subscription = new Observable((subscriber) => {\n            const workerDrivenSubscription = workerDrivenSubscriptions.subscribe(subscriber);\n            const subscriptionChanges = this.subscriptionChanges.subscribe(subscriber);\n            return () => {\n                workerDrivenSubscription.unsubscribe();\n                subscriptionChanges.unsubscribe();\n            };\n        });\n    }\n    /**\n     * Subscribes to Web Push Notifications,\n     * after requesting and receiving user permission.\n     *\n     * @param options An object containing the `serverPublicKey` string.\n     * @returns A Promise that resolves to the new subscription object.\n     */\n    requestSubscription(options) {\n        if (!this.sw.isEnabled || this.pushManager === null) {\n            return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n        }\n        const pushOptions = { userVisibleOnly: true };\n        let key = this.decodeBase64(options.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+'));\n        let applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));\n        for (let i = 0; i < key.length; i++) {\n            applicationServerKey[i] = key.charCodeAt(i);\n        }\n        pushOptions.applicationServerKey = applicationServerKey;\n        return new Promise((resolve, reject) => {\n            this.pushManager.pipe(switchMap((pm) => pm.subscribe(pushOptions)), take(1)).subscribe({\n                next: (sub) => {\n                    this.subscriptionChanges.next(sub);\n                    resolve(sub);\n                },\n                error: reject,\n            });\n        });\n    }\n    /**\n     * Unsubscribes from Service Worker push notifications.\n     *\n     * @returns A Promise that is resolved when the operation succeeds, or is rejected if there is no\n     *          active subscription or the unsubscribe operation fails.\n     */\n    unsubscribe() {\n        if (!this.sw.isEnabled) {\n            return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n        }\n        const doUnsubscribe = (sub) => {\n            if (sub === null) {\n                throw new _RuntimeError(5602 /* RuntimeErrorCode.NOT_SUBSCRIBED_TO_PUSH_NOTIFICATIONS */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    'Not subscribed to push notifications.');\n            }\n            return sub.unsubscribe().then((success) => {\n                if (!success) {\n                    throw new _RuntimeError(5603 /* RuntimeErrorCode.PUSH_SUBSCRIPTION_UNSUBSCRIBE_FAILED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Unsubscribe failed!');\n                }\n                this.subscriptionChanges.next(null);\n            });\n        };\n        return new Promise((resolve, reject) => {\n            this.subscription\n                .pipe(take(1), switchMap(doUnsubscribe))\n                .subscribe({ next: resolve, error: reject });\n        });\n    }\n    decodeBase64(input) {\n        return atob(input);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: SwPush, deps: [{ token: NgswCommChannel }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: SwPush });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: SwPush, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: NgswCommChannel }] });\n\n/**\n * Subscribe to update notifications from the Service Worker, trigger update\n * checks, and forcibly activate updates.\n *\n * @see {@link /ecosystem/service-workers/communications Service Worker Communication Guide}\n *\n * @publicApi\n */\nclass SwUpdate {\n    sw;\n    /**\n     * Emits a `VersionDetectedEvent` event whenever a new version is detected on the server.\n     *\n     * Emits a `VersionInstallationFailedEvent` event whenever checking for or downloading a new\n     * version fails.\n     *\n     * Emits a `VersionReadyEvent` event whenever a new version has been downloaded and is ready for\n     * activation.\n     */\n    versionUpdates;\n    /**\n     * Emits an `UnrecoverableStateEvent` event whenever the version of the app used by the service\n     * worker to serve this client is in a broken state that cannot be recovered from without a full\n     * page reload.\n     */\n    unrecoverable;\n    /**\n     * True if the Service Worker is enabled (supported by the browser and enabled via\n     * `ServiceWorkerModule`).\n     */\n    get isEnabled() {\n        return this.sw.isEnabled;\n    }\n    constructor(sw) {\n        this.sw = sw;\n        if (!sw.isEnabled) {\n            this.versionUpdates = NEVER;\n            this.unrecoverable = NEVER;\n            return;\n        }\n        this.versionUpdates = this.sw.eventsOfType([\n            'VERSION_DETECTED',\n            'VERSION_INSTALLATION_FAILED',\n            'VERSION_READY',\n            'NO_NEW_VERSION_DETECTED',\n        ]);\n        this.unrecoverable = this.sw.eventsOfType('UNRECOVERABLE_STATE');\n    }\n    /**\n     * Checks for an update and waits until the new version is downloaded from the server and ready\n     * for activation.\n     *\n     * @returns a promise that\n     * - resolves to `true` if a new version was found and is ready to be activated.\n     * - resolves to `false` if no new version was found\n     * - rejects if any error occurs\n     */\n    checkForUpdate() {\n        if (!this.sw.isEnabled) {\n            return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n        }\n        const nonce = this.sw.generateNonce();\n        return this.sw.postMessageWithOperation('CHECK_FOR_UPDATES', { nonce }, nonce);\n    }\n    /**\n     * Updates the current client (i.e. browser tab) to the latest version that is ready for\n     * activation.\n     *\n     * In most cases, you should not use this method and instead should update a client by reloading\n     * the page.\n     *\n     * <div class=\"docs-alert docs-alert-important\">\n     *\n     * Updating a client without reloading can easily result in a broken application due to a version\n     * mismatch between the application shell and other page resources,\n     * such as lazy-loaded chunks, whose filenames may change between\n     * versions.\n     *\n     * Only use this method, if you are certain it is safe for your specific use case.\n     *\n     * </div>\n     *\n     * @returns a promise that\n     *  - resolves to `true` if an update was activated successfully\n     *  - resolves to `false` if no update was available (for example, the client was already on the\n     *    latest version).\n     *  - rejects if any error occurs\n     */\n    activateUpdate() {\n        if (!this.sw.isEnabled) {\n            return Promise.reject(new _RuntimeError(5601 /* RuntimeErrorCode.SERVICE_WORKER_DISABLED_OR_NOT_SUPPORTED_BY_THIS_BROWSER */, (typeof ngDevMode === 'undefined' || ngDevMode) && ERR_SW_NOT_SUPPORTED));\n        }\n        const nonce = this.sw.generateNonce();\n        return this.sw.postMessageWithOperation('ACTIVATE_UPDATE', { nonce }, nonce);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: SwUpdate, deps: [{ token: NgswCommChannel }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: SwUpdate });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: SwUpdate, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: NgswCommChannel }] });\n\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nconst SCRIPT = new InjectionToken(ngDevMode ? 'NGSW_REGISTER_SCRIPT' : '');\nfunction ngswAppInitializer() {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        return;\n    }\n    const options = inject(SwRegistrationOptions);\n    if (!('serviceWorker' in navigator && options.enabled !== false)) {\n        return;\n    }\n    const script = inject(SCRIPT);\n    const ngZone = inject(NgZone);\n    const appRef = inject(ApplicationRef);\n    // Set up the `controllerchange` event listener outside of\n    // the Angular zone to avoid unnecessary change detections,\n    // as this event has no impact on view updates.\n    ngZone.runOutsideAngular(() => {\n        // Wait for service worker controller changes, and fire an INITIALIZE action when a new SW\n        // becomes active. This allows the SW to initialize itself even if there is no application\n        // traffic.\n        const sw = navigator.serviceWorker;\n        const onControllerChange = () => sw.controller?.postMessage({ action: 'INITIALIZE' });\n        sw.addEventListener('controllerchange', onControllerChange);\n        appRef.onDestroy(() => {\n            sw.removeEventListener('controllerchange', onControllerChange);\n        });\n    });\n    // Run outside the Angular zone to avoid preventing the app from stabilizing (especially\n    // given that some registration strategies wait for the app to stabilize).\n    ngZone.runOutsideAngular(() => {\n        let readyToRegister;\n        const { registrationStrategy } = options;\n        if (typeof registrationStrategy === 'function') {\n            readyToRegister = new Promise((resolve) => registrationStrategy().subscribe(() => resolve()));\n        }\n        else {\n            const [strategy, ...args] = (registrationStrategy || 'registerWhenStable:30000').split(':');\n            switch (strategy) {\n                case 'registerImmediately':\n                    readyToRegister = Promise.resolve();\n                    break;\n                case 'registerWithDelay':\n                    readyToRegister = delayWithTimeout(+args[0] || 0);\n                    break;\n                case 'registerWhenStable':\n                    readyToRegister = Promise.race([appRef.whenStable(), delayWithTimeout(+args[0])]);\n                    break;\n                default:\n                    // Unknown strategy.\n                    throw new _RuntimeError(5600 /* RuntimeErrorCode.UNKNOWN_REGISTRATION_STRATEGY */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                        `Unknown ServiceWorker registration strategy: ${options.registrationStrategy}`);\n            }\n        }\n        // Don't return anything to avoid blocking the application until the SW is registered.\n        // Catch and log the error if SW registration fails to avoid uncaught rejection warning.\n        readyToRegister.then(() => {\n            // If the registration strategy has resolved after the application has\n            // been explicitly destroyed by the user (e.g., by navigating away to\n            // another application), we simply should not register the worker.\n            if (appRef.destroyed) {\n                return;\n            }\n            navigator.serviceWorker\n                .register(script, { scope: options.scope })\n                .catch((err) => console.error(_formatRuntimeError(5604 /* RuntimeErrorCode.SERVICE_WORKER_REGISTRATION_FAILED */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                'Service worker registration failed with: ' + err)));\n        });\n    });\n}\nfunction delayWithTimeout(timeout) {\n    return new Promise((resolve) => setTimeout(resolve, timeout));\n}\nfunction ngswCommChannelFactory(opts, injector) {\n    const isBrowser = !(typeof ngServerMode !== 'undefined' && ngServerMode);\n    return new NgswCommChannel(isBrowser && opts.enabled !== false ? navigator.serviceWorker : undefined, injector);\n}\n/**\n * Token that can be used to provide options for `ServiceWorkerModule` outside of\n * `ServiceWorkerModule.register()`.\n *\n * You can use this token to define a provider that generates the registration options at runtime,\n * for example via a function call:\n *\n * {@example service-worker/registration-options/module.ts region=\"registration-options\"\n *     header=\"app.module.ts\"}\n *\n * @publicApi\n */\nclass SwRegistrationOptions {\n    /**\n     * Whether the ServiceWorker will be registered and the related services (such as `SwPush` and\n     * `SwUpdate`) will attempt to communicate and interact with it.\n     *\n     * Default: true\n     */\n    enabled;\n    /**\n     * A URL that defines the ServiceWorker's registration scope; that is, what range of URLs it can\n     * control. It will be used when calling\n     * [ServiceWorkerContainer#register()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).\n     */\n    scope;\n    /**\n     * Defines the ServiceWorker registration strategy, which determines when it will be registered\n     * with the browser.\n     *\n     * The default behavior of registering once the application stabilizes (i.e. as soon as there are\n     * no pending micro- and macro-tasks) is designed to register the ServiceWorker as soon as\n     * possible but without affecting the application's first time load.\n     *\n     * Still, there might be cases where you want more control over when the ServiceWorker is\n     * registered (for example, there might be a long-running timeout or polling interval, preventing\n     * the app from stabilizing). The available option are:\n     *\n     * - `registerWhenStable:<timeout>`: Register as soon as the application stabilizes (no pending\n     *     micro-/macro-tasks) but no later than `<timeout>` milliseconds. If the app hasn't\n     *     stabilized after `<timeout>` milliseconds (for example, due to a recurrent asynchronous\n     *     task), the ServiceWorker will be registered anyway.\n     *     If `<timeout>` is omitted, the ServiceWorker will only be registered once the app\n     *     stabilizes.\n     * - `registerImmediately`: Register immediately.\n     * - `registerWithDelay:<timeout>`: Register with a delay of `<timeout>` milliseconds. For\n     *     example, use `registerWithDelay:5000` to register the ServiceWorker after 5 seconds. If\n     *     `<timeout>` is omitted, is defaults to `0`, which will register the ServiceWorker as soon\n     *     as possible but still asynchronously, once all pending micro-tasks are completed.\n     * - An Observable factory function: A function that returns an `Observable`.\n     *     The function will be used at runtime to obtain and subscribe to the `Observable` and the\n     *     ServiceWorker will be registered as soon as the first value is emitted.\n     *\n     * Default: 'registerWhenStable:30000'\n     */\n    registrationStrategy;\n}\n/**\n * @publicApi\n *\n * Sets up providers to register the given Angular Service Worker script.\n *\n * If `enabled` is set to `false` in the given options, the module will behave as if service\n * workers are not supported by the browser, and the service worker will not be registered.\n *\n * Example usage:\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideServiceWorker('ngsw-worker.js')\n *   ],\n * });\n * ```\n */\nfunction provideServiceWorker(script, options = {}) {\n    return makeEnvironmentProviders([\n        SwPush,\n        SwUpdate,\n        { provide: SCRIPT, useValue: script },\n        { provide: SwRegistrationOptions, useValue: options },\n        {\n            provide: NgswCommChannel,\n            useFactory: ngswCommChannelFactory,\n            deps: [SwRegistrationOptions, Injector],\n        },\n        provideAppInitializer(ngswAppInitializer),\n    ]);\n}\n\n/**\n * @publicApi\n */\nclass ServiceWorkerModule {\n    /**\n     * Register the given Angular Service Worker script.\n     *\n     * If `enabled` is set to `false` in the given options, the module will behave as if service\n     * workers are not supported by the browser, and the service worker will not be registered.\n     */\n    static register(script, options = {}) {\n        return {\n            ngModule: ServiceWorkerModule,\n            providers: [provideServiceWorker(script, options)],\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ServiceWorkerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"19.2.15\", ngImport: i0, type: ServiceWorkerModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ServiceWorkerModule, providers: [SwPush, SwUpdate] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ServiceWorkerModule, decorators: [{\n            type: NgModule,\n            args: [{ providers: [SwPush, SwUpdate] }]\n        }] });\n\nexport { ServiceWorkerModule, SwPush, SwRegistrationOptions, SwUpdate, provideServiceWorker };\n"],"mappings":"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C;QACXD,IAAI,EAAEuB,OAAO;QACb3B,KAAK,EAAE4C;MACX,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA,IAAIG,SAASA,CAAA,EAAG;IACZ,OAAO,CAAC,CAAC,IAAI,CAACtD,aAAa;EAC/B;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMuD,MAAM,CAAC;EACTpB,EAAE;EACF;AACJ;AACA;EACIqB,QAAQ;EACR;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,kBAAkB;EAClB;AACJ;AACA;AACA;AACA;EACIC,YAAY;EACZ;AACJ;AACA;AACA;EACI,IAAIJ,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACnB,EAAE,CAACmB,SAAS;EAC5B;EACAK,WAAW,GAAG,IAAI;EAClBC,mBAAmB,GAAG,IAAIpE,OAAO,CAAC,CAAC;EACnCY,WAAWA,CAAC+B,EAAE,EAAE;IACZ,IAAI,CAACA,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACA,EAAE,CAACmB,SAAS,EAAE;MACf,IAAI,CAACE,QAAQ,GAAG/D,KAAK;MACrB,IAAI,CAACgE,kBAAkB,GAAGhE,KAAK;MAC/B,IAAI,CAACiE,YAAY,GAAGjE,KAAK;MACzB;IACJ;IACA,IAAI,CAAC+D,QAAQ,GAAG,IAAI,CAACrB,EAAE,CAACW,YAAY,CAAC,MAAM,CAAC,CAAC7B,IAAI,CAACpB,GAAG,CAAEgE,OAAO,IAAKA,OA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}