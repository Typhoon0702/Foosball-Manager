{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Version, isDevMode, inject, NgZone, Injectable, runInInjectionContext, PendingTasks, EnvironmentInjector } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { pendingUntilEvent } from '@angular/core/rxjs-interop';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { subscribeOn, observeOn } from 'rxjs/operators';\nconst VERSION = /*#__PURE__*/new Version('ANGULARFIRE2_VERSION');\nconst ɵisSupportedError = module => `The APP_INITIALIZER that is \"making\" isSupported() sync for the sake of convenient DI has not resolved in this\ncontext. Rather than injecting ${module} in the constructor, first ensure that ${module} is supported by calling\n\\`await isSupported()\\`, then retrieve the instance from the injector manually \\`injector.get(${module})\\`.`;\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n  if (provided) {\n    // Was provide* only called once? If so grab that\n    if (provided.length === 1) {\n      return provided[0];\n    }\n    const providedUsingDefaultApp = provided.filter(it => it.app === defaultApp);\n    // Was provide* only called once, using the default app? If so use that\n    if (providedUsingDefaultApp.length === 1) {\n      return providedUsingDefaultApp[0];\n    }\n  }\n  // Grab the default instance from the defaultApp\n  const defaultAppWithContainer = defaultApp;\n  const provider = defaultAppWithContainer.container.getProvider(identifier);\n  return provider.getImmediate({\n    optional: true\n  });\n}\nconst ɵgetAllInstancesOf = (identifier, app) => {\n  const apps = app ? [app] : getApps();\n  const instances = [];\n  apps.forEach(app => {\n    const provider = app.container.getProvider(identifier);\n    provider.instances.forEach(instance => {\n      if (!instances.includes(instance)) {\n        instances.push(instance);\n      }\n    });\n  });\n  return instances;\n};\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nvar LogLevel = /*#__PURE__*/function (LogLevel) {\n  LogLevel[LogLevel[\"SILENT\"] = 0] = \"SILENT\";\n  LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n  LogLevel[LogLevel[\"VERBOSE\"] = 2] = \"VERBOSE\";\n  return LogLevel;\n}(LogLevel || {});\nvar currentLogLevel = /*#__PURE__*/isDevMode() && typeof Zone !== \"undefined\" ? LogLevel.WARN : LogLevel.SILENT;\nconst setLogLevel = logLevel => currentLogLevel = logLevel;\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nclass ɵZoneScheduler {\n  zone;\n  delegate;\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  now() {\n    return this.delegate.now();\n  }\n  schedule(work, delay, state) {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (state) {\n      if (targetZone) {\n        targetZone.runGuarded(() => {\n          work.apply(this, [state]);\n        });\n      } else {\n        work.apply(this, [state]);\n      }\n    };\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n}\nlet ɵAngularFireSchedulers = /*#__PURE__*/(() => {\n  class ɵAngularFireSchedulers {\n    outsideAngular;\n    insideAngular;\n    constructor() {\n      const ngZone = inject(NgZone);\n      this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current));\n      this.insideAngular = ngZone.run(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current, asyncScheduler));\n    }\n    static ɵfac = function ɵAngularFireSchedulers_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ɵAngularFireSchedulers)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ɵAngularFireSchedulers,\n      factory: ɵAngularFireSchedulers.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ɵAngularFireSchedulers;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar alreadyWarned = false;\nfunction warnOutsideInjectionContext(original, logLevel) {\n  if (!alreadyWarned && (currentLogLevel > LogLevel.SILENT || isDevMode())) {\n    alreadyWarned = true;\n    console.warn(\"Calling Firebase APIs outside of an Injection context may destabilize your application leading to subtle change-detection and hydration bugs. Find more at https://github.com/angular/angularfire/blob/main/docs/zones.md\");\n  }\n  if (currentLogLevel >= logLevel) {\n    console.warn(`Firebase API called outside injection context: ${original.name}`);\n  }\n}\nfunction runOutsideAngular(fn) {\n  const ngZone = inject(NgZone, {\n    optional: true\n  });\n  if (!ngZone) {\n    return fn();\n  }\n  return ngZone.runOutsideAngular(() => fn());\n}\nfunction run(fn) {\n  const ngZone = inject(NgZone, {\n    optional: true\n  });\n  if (!ngZone) {\n    return fn();\n  }\n  return ngZone.run(() => fn());\n}\nconst zoneWrapFn = (it, taskDone, injector) => {\n  return (...args) => {\n    if (taskDone) {\n      setTimeout(taskDone, 0);\n    }\n    return runInInjectionContext(injector, () => run(() => it.apply(this, args)));\n  };\n};\nconst ɵzoneWrap = (it, blockUntilFirst, logLevel) => {\n  logLevel ||= blockUntilFirst ? LogLevel.WARN : LogLevel.VERBOSE;\n  // function() is needed for the arguments object\n  return function () {\n    let taskDone;\n    const _arguments = arguments;\n    let schedulers;\n    let pendingTasks;\n    let injector;\n    try {\n      schedulers = inject(ɵAngularFireSchedulers);\n      pendingTasks = inject(PendingTasks);\n      injector = inject(EnvironmentInjector);\n    } catch (e) {\n      warnOutsideInjectionContext(it, logLevel);\n      return it.apply(this, _arguments);\n    }\n    // if this is a callback function, e.g, onSnapshot, we should create a pending task and complete it\n    // only once one of the callback functions is tripped.\n    for (let i = 0; i < arguments.length; i++) {\n      if (typeof _arguments[i] === 'function') {\n        if (blockUntilFirst) {\n          taskDone ||= run(() => pendingTasks.add());\n        }\n        // TODO create a microtask to track callback functions\n        _arguments[i] = zoneWrapFn(_arguments[i], taskDone, injector);\n      }\n    }\n    const ret = runOutsideAngular(() => it.apply(this, _arguments));\n    if (!blockUntilFirst) {\n      if (ret instanceof Observable) {\n        return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      } else {\n        return run(() => ret);\n      }\n    }\n    if (ret instanceof Observable) {\n      return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), pendingUntilEvent(injector));\n    } else if (ret instanceof Promise) {\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      return run(() => new Promise((resolve, reject) => {\n        pendingTasks.run(() => ret).then(it => runInInjectionContext(injector, () => run(() => resolve(it))), reason => runInInjectionContext(injector, () => run(() => reject(reason))));\n      }));\n    } else if (typeof ret === 'function' && taskDone) {\n      // Handle unsubscribe\n      // function() is needed for the arguments object\n      return function () {\n        setTimeout(taskDone, 0);\n        return ret.apply(this, arguments);\n      };\n    } else {\n      // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n      return run(() => ret);\n    }\n  };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LogLevel, VERSION, setLogLevel, ɵAngularFireSchedulers, ɵZoneScheduler, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵisSupportedError, ɵzoneWrap };\n//# sourceMappingURL=angular-fire.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}